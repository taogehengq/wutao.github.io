<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>AI agent 开发知识总结 | WT's Blog</title><meta name="author" content="WT"><meta name="copyright" content="WT"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="AI agent 开发知识总结什么是agent？ Agent（智能体 &#x2F; 自主代理）在 LLM 驱动的语境下，Agent 指以大规模语言模型为核心控制器（brain），配合记忆（memory）、工具调用（tool use）、规划（planning）与行动（action）模块，形成能够感知环境、制定计划并调用外部 API、函数或机器人执行多步任务，最终完成复杂目标的自治软件实体。它通常遵循">
<meta property="og:type" content="article">
<meta property="og:title" content="AI agent 开发知识总结">
<meta property="og:url" content="https://wutaoblog.github.io/2026/01/11/AI%20agent%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="WT&#39;s Blog">
<meta property="og:description" content="AI agent 开发知识总结什么是agent？ Agent（智能体 &#x2F; 自主代理）在 LLM 驱动的语境下，Agent 指以大规模语言模型为核心控制器（brain），配合记忆（memory）、工具调用（tool use）、规划（planning）与行动（action）模块，形成能够感知环境、制定计划并调用外部 API、函数或机器人执行多步任务，最终完成复杂目标的自治软件实体。它通常遵循">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2026-01-11T02:00:00.000Z">
<meta property="article:modified_time" content="2026-01-11T07:10:31.547Z">
<meta property="article:author" content="WT">
<meta property="article:tag" content="Hexo">
<meta property="article:tag" content="agent">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "AI agent 开发知识总结",
  "url": "https://wutaoblog.github.io/2026/01/11/AI%20agent%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/",
  "image": "https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png",
  "datePublished": "2026-01-11T02:00:00.000Z",
  "dateModified": "2026-01-11T07:10:31.547Z",
  "author": [
    {
      "@type": "Person",
      "name": "WT",
      "url": "https://wutaoblog.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wutaoblog.github.io/2026/01/11/AI%20agent%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AI agent 开发知识总结',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(https://s2.loli.net/2024/01/08/2NLQjw1oVCxdg4v.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archives"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">WT's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">AI agent 开发知识总结</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archives"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">AI agent 开发知识总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-11T02:00:00.000Z" title="发表于 2026-01-11 10:00:00">2026-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-11T07:10:31.547Z" title="更新于 2026-01-11 15:10:31">2026-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="AI-agent-开发知识总结"><a href="#AI-agent-开发知识总结" class="headerlink" title="AI agent 开发知识总结"></a>AI agent 开发知识总结</h1><p>什么是agent？</p>
<p>Agent（智能体 &#x2F; 自主代理）<br>在 LLM 驱动的语境下，Agent 指以大规模语言模型为核心控制器（brain），配合记忆（memory）、工具调用（tool use）、规划（planning）与行动（action）模块，形成能够感知环境、制定计划并调用外部 API、函数或机器人执行多步任务，最终完成复杂目标的自治软件实体。它通常遵循观察（observe）→ 思考（reason）→ 行动（act）的循环，支持多轮对话、状态更新和任务拆解。<strong>一句话解释就是：给 AI 装上记忆、手脚和工具，让它像人一样自己思考、查资料、做任务，直到把事情办完。</strong></p>
<p>本质上，所有的 Agent 设计模式都是将人类的思维、管理模式以结构化prompt的方式告诉大模型来进行规划，并调用工具执行，且不断迭代的方法,从这个角度来说，Agent设计模式很像传统意义上的程序开发范式，但是泛化和场景通用性远大于传统的程序开发范式。在Agent设计模式中，Prompt可以类比为Python这类高级编程语言，大模型可以类比于程序语言编译&amp;解释器。</p>
<p>任务规划详解</p>
<p>子目标拆解，将复杂任务分解为多个子任务，按需串行或并行处理。</p>
<p>并行处理结构，通常采用有向无环图（DAG）表示。</p>
<p>反思与完善，AI在解决问题过程中通过大模型进行纠错和优化，形成反思机制。</p>
<p>React机制，思考 → 行动 → 观察 → 迭代循环，直至问题解决。</p>
<p>开发注意事项  </p>
<p>提示词质量重要性<br>大模型能力有限，依赖高质量提示词提升理解与任务拆解效果。逻辑推理能力不足<br>当前大模型在数学与逻辑推理方面较弱，需通过COT（思维链）增强。执行能力依赖函数调用<br>大模型本身无执行能力，需通过函数调用实现动作。模型选择参考指标<br>如伯克利大学方格申克榜单，GPT-4系列单次函数调用准确率约80%。记忆与反思能力关联<br>反思能力依赖于记忆能力，需同时优化短期与长期记忆机制。</p>
<p>应用领域  </p>
<p>客户服务：基于增强知识提供服务。</p>
<p>医疗诊断：通过设备获取信息辅助诊断。</p>
<p>金融方向：交易决策支持。</p>
<p>智能交通：自动驾驶、无人驾驶。</p>
<p>教育：AI大模型推动教育数字化转型。</p>
<p>程序开发范式变化：AI Agent降低人类思维管理模式，通过结构化提示词进行任务规划与执行。</p>
<h2 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h2><ul>
<li>提示词工程的作用</li>
</ul>
<p>提升大语言模型输出能力。不需更新模型权重和参数即可改善输出。</p>
<p>应用场景</p>
<p>从数学公式推导到文章写作、编程等多个领域。</p>
<p>提示词分类</p>
<p>包括zero shot提示词、few shot提示词、思维链（COT）、自我批判与反思、任务拆解（如TOT）等多种技巧。</p>
<ul>
<li>提示词技巧与使用方法</li>
</ul>
<p>zero shot提示词</p>
<p>直接让模型输出所需结果，无需额外样本。</p>
<p>few shot提示词</p>
<p>遇到复杂任务时，提供少量相关示例帮助模型理解任务结构。</p>
<p>示例：情感分析任务中提供输入与输出示例。</p>
<p>思维链（COT）</p>
<p>few shot COT<br>提供推理示例，让模型模仿推理过程。<br>例：罗杰有5个网球，买了2罐，每罐3个，总共有 5 + 2 \times 3 &#x3D; 11 个。</p>
<p>zero shot COT<br>无需示例，通过提示“让我们一步步思考”激活模型推理能力。<br>例：计算苹果数量变化时逐步推理。</p>
<ul>
<li>自一致性（Self-Consistency）</li>
</ul>
<p> 核心思想多路径推理，通过多数投票机制确定最终答案。应用示例同一问题采用不同思路推理，若多数结果一致，则认为该结果为正确答案。例：计算苹果数量，三次推理中有两次得到相同结果，则该结果为最终答案。</p>
<ul>
<li>TOT（Tree of Thought）</li>
</ul>
<p>基本原理类似编程中的树结构，分步骤思考并评估可行性，最终选择最优路径。使用示例多位专家分步骤思考问题，逐步推进并选择最优解。</p>
<ul>
<li>Q*STAR提示词框架</li>
</ul>
<p>框架组成Context（上下文）：明确问题背景和任务描述。Objective（目标）：说明需解决的问题。Style（风格）：如以CEO风格撰写报告。Tone（语调）：如幽默、正式、亲切等。Audience（受众）：如30岁工程师、大学生等。Response（答复格式）：如报告、表格、代码等。应用示例用于撰写小红书推广文案，吸引目标用户购买AI编程课程。用于论文阅读助手模板，提取研究问题、方法、发现并评估质量。</p>
<p>Q*STAR提示词列子:</p>
<p>论文阅读助手提示词模版</p>
<p>Context(背景)</p>
<p>作为一名学者或研究人员，阅读和理解学术论文是一项日常任务。然而，由于时间限制和论文数量的增加，快速准确地获取论文的关键信息变得尤为重要。”论文间读助手”旨在帮助用户高效地筛选和理解学术论文，专注于提供论文的核心观点、研究方法、主要发现和结论。</p>
<p>obiective(目标)</p>
<p>“论文阅读助手”的目标是:<br>1.提取并总结论文的研究问题、目的和背景。<br>2.明确论文的研究方法和数据来源。<br>3.突出论文的主要发现、结论和可能的影响。<br>4.评估论文的质量和相关性，为用户的研究提供参考。</p>
<p>Style(风格)</p>
<p>“论文阅读助手”的写作风格应是学术性的、客观的，同时要清晰和易于理解。避免过度使用行业术语，除非对理解内容至关重要。</p>
<p>Tone(语调)</p>
<p>语调应保持中立和专业，同时传达出对学术研究的尊重和对用户需求的同情理解。</p>
<p>Audience(受众)</p>
<p>目标受众是学术研究人员、学者、大学生以及任何需要深入理解学术论文的专业人士<br>Response(回应)</p>
<p>“”论文阅读助手”的回应格式应包括以下部分:<br>-标题和作者:提供论文的标题和作者信息。<br>摘要:提供论文摘要的精简版，突出研究问题和目的。<br>研究方法:简要描述研究设计、样本、数据收集和分析方法。<br>主要发现:总结论文的关键结果和数据。<br>结论:概述作者的结论和对研究领域的潜在影响。<br>批判性评价:提供对论文质量、方法和结论的简要评估。<br>推荐阅读:如果适用，推荐相关的进一步阅读材料。</p>
<h2 id="API评测"><a href="#API评测" class="headerlink" title="API评测"></a>API评测</h2><p>API-Bank评估体系 </p>
<p> 用于评估大模型工具调用能力的评测项目。包含论文、代码库和评测数据集。类似伯克利榜单，提供模型调用能力参考。</p>
<p>API-Bank三大评估层级 </p>
<p> 第一层：提示词明确描述API使用方式，模型识别并调用。第二层：提示词不明确，模型需自行判断调用哪个API及所需参数。第三层：需求与目标均不明确，需通过多个API调用步骤解决问题，如规划旅行路线、预定航班、门票、酒店等。</p>
<p>API-Bank评估资源 </p>
<p> GitHub项目提供LV1、LV2测试数据及评估脚本。LV3用于第三阶段评估，支持大模型函数调用能力的评测与训练提升。</p>
<h2 id="agent设计模式"><a href="#agent设计模式" class="headerlink" title="agent设计模式"></a>agent设计模式</h2><p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250801163934207.png" alt="image-20250801163934207"></p>
<p>React机制详解 </p>
<p> react是边思考边生成action的机制，具有非系统性。提出先规划再生成action的优化策略（plan and shove）。由于token消耗大，进一步优化为review机制，一次性生成工具调用以减少token。</p>
<p>React机制的核心思想</p>
<p>增强动作空间，将语言模型空间与动作空间结合。利用few-shot上下文学习生成action与sort。每个in-context学习样例包含action、sort、observe的行为轨迹。</p>
<p>React流程图详解 </p>
<p> 用户输入提示词 + React提示词模板 → 合并为few-shot提示词 → 大模型生成action参数。本地代码解析action参数并执行API调用。调用结果返回 → 转换为自然语言 → 判断任务是否完成。若未完成 → 继续循环；若完成 → 生成最终答案。</p>
<h2 id="提示工程中的多种设计模式"><a href="#提示工程中的多种设计模式" class="headerlink" title="提示工程中的多种设计模式"></a>提示工程中的多种设计模式</h2><p>​           包括Plan-and-Solve（PS）及其改进版PS+、Reasoning without Action（RwA）、LM Compiler 和 Basic Reflection 模式，旨在提升大模型在多步推理、任务规划、并行执行和自我反思等方面的表现。	</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803140519176.png" alt="image-20250803140519176"></p>
<p>Plan-and-Solve (PS) 模式 </p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803141523487.png" alt="image-20250803141523487"></p>
<p>论文背景<br>该模式来自2023年5月的一篇论文，用于提升大模型在多步推理任务中的表现，特别是Zero-Shot推理能力。</p>
<p>错误分析<br>Zero-Shot Chain-of-Thought（COT）存在三种主要错误：基层错误（7%）步骤缺失（12%）语义理解错误（27%）</p>
<p>解决方案<br>提出 Plan-and-Solve（PS）模式，分为两个阶段：1. 规划阶段：将任务分解为多个子任务。2. 执行阶段：根据规划逐步执行任务。</p>
<p>示例说明React 模式适用于固定流程（如厨房拿酱油）。PS 模式适用于动态流程（如西红柿炒鸡蛋），允许在执行过程中变更计划（如发现无西红柿则去购买）。</p>
<p>实现原理用户发起请求 → 大模型生成任务列表 → 执行每个任务 → 更新结果 → 判断是否符合预期。若不符合预期，重新规划并执行。</p>
<p>PS 提示词结构  </p>
<p> 基本结构制定计划（Device a Plan）：理解问题并制定解决计划。</p>
<p>执行计划（Carry out the Plan）：逐步执行计划并解决问题。PS+ 提示词改进增加中间变量提取和数字计算。强调计算准确性和常识推理。提升推理质量和计算能力。</p>
<p>Reasoning without Action (RwA) 模式</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803141338006.png" alt="image-20250803141338006"></p>
<p>动机<br>减少大模型的 token 消耗，提高效率。</p>
<p>核心思想 </p>
<p>将推理与外部观察分离。先规划所有步骤，再一次性执行并总结。</p>
<p>实现流程</p>
<p> 规划器生成任务列表。执行器调用工具并生成结果。合并器将结果整合后输入大模型进行总结。</p>
<p>提示词模板</p>
<p> 每个步骤依赖前一步输出。工具调用 结果作为变量注入后续提示词上下文。</p>
<p>LM Compiler 模式</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803141850759.png" alt="image-20250803141850759"></p>
<p>背景<br>传统调用工具的方式是串行执行，效率低。</p>
<p>改进<br>支持并行调用工具，提升执行效率。</p>
<p>任务依赖结构</p>
<p>有向无环图（DAG）表示任务之间的依赖关系。可并行任务同时执行，不可并行任务串行执行。</p>
<p>系统组成</p>
<p>规划器：生成任务的 DAG。1. 2. 并行执行器：根据依赖关系调度任务。3. 合并器：汇总结果并反馈用户或重新规划。</p>
<p>Basic Reflection 模式  </p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803142130849.png" alt="image-20250803142130849"></p>
<p>原理<br>模拟学生与老师之间的互动：生成器：负责生成结果。反思器：负责评价并提出修改建议。</p>
<p>流程</p>
<p>用户请求 → 生成器生成初步结果 → 反思器评价并反馈 → 生成器根据反馈修改 → 循环直至满足要求。</p>
<p>应用场景</p>
<p>内容生成（如文章、论文）图像生成代码生成</p>
<p>局限性</p>
<p>对生成器能力要求高。循环次数难以控制，影响成本与效果。</p>
<p>优化方向</p>
<p>Self-Discover（边推理边执行）Reflection with Reinforcement Learning（引入强化学习）</p>
<p>Reflection</p>
<p>Reflection是一种基于提示词的强化学习方法，通过语言反馈信号改进大模型的推理效果。与传统强化学习不同，reflection不依赖参数更新，而是将参数信号转化为语言总结并添加到模型上下文中。</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803142926560.png" alt="image-20250803142926560"></p>
<p>工作流程</p>
<p>第一步：使用简单的提示词和初始上下文生成结果。第二步：根据生成结果更新上下文，进行迭代优化。多次迭代后，生成结果质量逐步提升。</p>
<p>Reflection的核心组成部分</p>
<p>轨迹（Trajectory）</p>
<p>指一系列推理步骤及工具使用过程。</p>
<p>Actor</p>
<p>由大语言模型担任，根据当前上下文生成下一步动作。</p>
<p>评估器</p>
<p>评估Actor生成结果的质量，类似于强化学习中的奖励函数。</p>
<p>自我反思</p>
<p>根据生成结果与轨迹生成语言反馈信号，用于后续迭代。</p>
<p>Memory</p>
<p>存储短期与长期记忆：短期记忆：单次实验的上下文。长期记忆：多次实验中的反思结果与推理轨迹。</p>
<p>Language Agent Tree Search（Nets）原理</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803143345564.png" alt="image-20250803143345564"></p>
<p> 核心思想</p>
<p>结合蒙特卡罗树搜索（MCTS）、自我反思机制与强化学习。</p>
<p>主要流程</p>
<p>选择 → 扩展 → 评估 → 反向传播 → 模拟推理。</p>
<p>自我反思机制</p>
<p>从失败轨迹中学习，提升决策能力。</p>
<p>应用场景</p>
<p>解决自然语言推理与决策问题。</p>
<p>LATS执行与评估机制 </p>
<p>模拟推理</p>
<p>通过大语言模型生成多个可能路径。</p>
<p>评分机制</p>
<p>对生成路径进行评分，选择最优路径。</p>
<p>反向传播</p>
<p>将评分结果反向传播至根节点，更新路径权重与分数。</p>
<p>迭代优化</p>
<p>不断生成新节点、反思、评估、更新路径分数，直至达到设定的搜索深度或迭代次数。</p>
<p>LATS与其他框架对比</p>
<p>React</p>
<p>基于推理与行动的循环结构。</p>
<p>Tot</p>
<p>每个决策生成子决策，寻找最优方案。</p>
<p>Cot</p>
<p>链式推理，提供中间步骤。</p>
<p>Reflection</p>
<p>强化学习与反思机制结合，提升推理质量。</p>
<p>Self Discover设计模式 </p>
<p> 核心思想</p>
<p>自我发现机制，结合基础工具与原子推理模块解决问题。</p>
<p>优势</p>
<p>提升大语言模型处理复杂推理任务的能力。相比COT提升32%性能。计算资源消耗低，迁移性强。</p>
<p>应用流程</p>
<p>第一阶段：发现推理结构选择：从原子推理模块中选择适用方法。适应：调整模块描述，使其适应具体任务。实施：根据改写后的推理步骤生成可执行结构。</p>
<p>第二阶段：执行推理结构调用结构化推理模块。输入任务描述，执行推理。</p>
<h2 id="Agent开发"><a href="#Agent开发" class="headerlink" title="Agent开发"></a>Agent开发</h2><p>Agent开发注意事项</p>
<p> 安全性要求<br>若Agent具有文件系统访问权限，在所有情况下均不安全。运行环境建议<br>建议在Docker容器下运行和测试Agent。</p>
<p>单Agent静态框架</p>
<p>优点</p>
<p>设计简单，代码工作量少。无需考虑多Agent进程之间的交互和协调。针对特定任务进行优化，效率高，部署快，资源需求少，成本效益好。</p>
<p>缺点</p>
<p>复杂任务难以由单一Agent完成。扩展性差，功能增加需重新开发。鲁棒性差，单点故障导致系统失效。</p>
<p>常见单Agent项目  </p>
<p> Baby AGI</p>
<p>早期Agent项目，采用任务分解、优先级排序、执行、结果整合流程。设计思想影响后续Agent项目。</p>
<p>Auto GPT</p>
<p>基于GPT-3.5，作为个人助理帮助用户完成调研等任务。强调使用外部工具（如搜索引擎），功能全面但有局限（工具有限、无法控制迭代次数）。HuggingGPT</p>
<p>2023年3月发布，由浙大与微软联合开发。使用ChatGPT做任务规划，调用Hugging Face平台模型执行任务。最终由ChatGPT总结输出。</p>
<p>GPT Engineer</p>
<p>基于Cold-Start开发，专注于解决编码场景中的Bug问题。对AI程序员项目有启发。</p>
<p>APPA Agen</p>
<p>t腾讯开源，支持多款APP操作，类AutoGLM。基于Deeplearning4j与GPT-5U模型，支持多模态处理。需要系统Root权限，仅支持安卓。</p>
<p>OS Copilot</p>
<p>2024年2月发布，支持Windows、macOS、Linux系统。可自动完成Excel绘图、创建网站等任务。支持多模态大模型，具备自我学习能力。</p>
<p>多Agent静态框架  </p>
<p> 架构特点多Agent按工作流编排，各自负责不同任务，形成类似组织结构。任务结果依次传递，形成流水线作业。</p>
<p>示例：智慧城市数据分析</p>
<p>Agent 1：收集数据（气象、交通、环保部门），清洗、格式转换。</p>
<p>Agent 2：加载并深度分析数据。</p>
<p>Agent 3：生成可视化图表。</p>
<p>优点</p>
<p>支持复杂任务协作。扩展性强，可增加Agent。容错性好，支持互为备份。支持分布式部署，提升吞吐量。提高各Agent领域的解决能力。</p>
<p>缺点</p>
<p>实现复杂，需通信与协调。开发难度大，成本高。</p>
<p>多Agent项目案例  </p>
<p>斯坦福虚拟小镇</p>
<p>模拟人类行为的虚拟社区，包含25个Agent。使用ChatGPT实现自然语言交互。Agent具有社交行为（工作、八卦、组织活动等）。影响后续多Agent框架设计。Task Waver</p>
<p>数据分析Agent，通过代码片段解释用户需求。关键组件：规划器、代码生成器、代码执行器。</p>
<p>Meta GPT</p>
<p>国内开源多Agent框架，活跃度高。构建软件公司微缩模型（产品经、架构师、工程师、测试等角色）。支持Think、Observe、Act、Publish机制。</p>
<p>微软UFO</p>
<p>双Agent架构（App Agent与Act Agent）。App Agent选择软件，Act Agent执行操作（点击、拖动等）。支持多模态识别界面信息。</p>
<p>AgentScope</p>
<p>阿里开源多Agent框架。支持分布式架构，通信使用gRPC协议。</p>
<p>常见agent项目比较</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803151657482.png" alt="image-20250803151657482"></p>
<p>典型项目比较</p>
<p>LangGraph：基于图与头的多Agent开发平台，扩展性强。</p>
<p>AutoGPT：自动代码生成平台，开发简单。</p>
<p>CrewAI：适用于复杂多Agent系统开发，基于云平台。开发难度AutoGPT最低，CrewAI较高，LangGraph中等。扩展性LangGraph与CrewAI较高，AutoGPT中等。集成能力AutoGPT最高，CrewAI最低。</p>
<p>Chat Chain模式解析  </p>
<p>核心机制</p>
<p>多Agent通过聊天形式协作完成任务。每个角色有系统提示词与能力指派。通过提示词激发大模型能力，完善用户需求，拆解任务步骤。适用项目CrewAI、AutoGPT、Chatgen等。优势支持任务分解与分配。支持多种交互模式（顺序聊天、群聊等）。提升复杂问题解决成功率、效率、灵活性与扩展性。</p>
<h2 id="LangChain"><a href="#LangChain" class="headerlink" title="LangChain"></a>LangChain</h2><p>是一个基于开源大元模型的AI工程开发框架，提供丰富的工具集成，帮助工程师高效开发AI应用。</p>
<p>浪欠（LangChain）框架的核心架构、功能模块及使用方法，包括其模型、提示词模板、索引、记忆、链和代理等六大模块，实际开发中的调用流程、链式组合、回调机制和Agent执行逻辑。</p>
<p>三层架构模型 </p>
<p>抽象层：包含模型、检索、Agent、Chain、Memory等核心模块。</p>
<p>实现层：社区支持，提供具体实现。</p>
<p>整合层：整合各模块，构建完整项目。</p>
<p>六大核心模块概述  </p>
<p> 模型：封装大语言模型、聊天模型、嵌入模型等。</p>
<p>提示词：提供模板与占位符，支持绑定角色。</p>
<p>索引：文档加载器、转换器、文本分割器、向量存储器、检索器。</p>
<p>记忆：记录聊天历史、状态，支持窗口记忆、带总结记忆、知识图谱记忆。</p>
<p>链（Chain）：通过竖杠串联组件，简化代码逻辑。</p>
<p>代理（Agent）：支持函数调用、工具使用，实现自动决策。</p>
<p>LCEL（LangChain Expression Language）详解</p>
<p> 原理<br>通过重载魔术方法（如 <strong>call____add</strong>、、<strong>or</strong>）实现链式调用。</p>
<p>规范<br>支持统一接口：invoke：同步调用batch：批量调用stream：流式输出ainvoke：异步调用组合原理<br>通过魔术方法轻松组合链、并行化组件。</p>
<p>回调（Callback）机制  </p>
<p>功能<br>用于监控日志、调试流程。实现方式<br>自定义类继承 BaseCallbackHandler，实现如 on_chain_start 等回调函数。使用示例<br>在调用链时传入回调处理器，记录调用过程。</p>
<p>Agent 执行流程  </p>
<p> 流程步骤</p>
<ol>
<li>用户发起请求</li>
<li>Agent 接收请求，结合系统提示词、请求内容、工具描述</li>
<li>大模型返回调用函数及参数</li>
<li>Agent 解析并调用函数，获取结果</li>
<li>将结果拼接提示词，再次调用大模型</li>
<li>大模型输出结果，Agent 解析后返回给用户</li>
</ol>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803153843076.png" alt="image-20250803153843076"></p>
<p>示例一：Tool 调用<br>使用浪欠实现层提供的工具，创建 React Agent，指定大模型与 Tool，执行调用。</p>
<p>示例二：Memory 使用<br>使用 3D Net 数据库存储聊天记录，创建带 Memory 的 Agent，执行流式输出。</p>
<p>自定义工具<br>定义一个搜索函数，通过 @tool 注解注册为工具，供 Agent 调用。</p>
<h2 id="LangGraph"><a href="#LangGraph" class="headerlink" title="LangGraph"></a>LangGraph</h2><p>基于有向无环图（DAG）设计，但支持循环，适用于需要迭代的高级 agent 设计模式。</p>
<p>核心优势</p>
<p>支持循环执行，便于实现不断迭代的任务。</p>
<p>提供精细的工作流控制台，用于管理 agent 的流程与状态。</p>
<p>支持在执行过程中中断并进行人机交互。</p>
<p>基本概念与原理 </p>
<p> 图结构原理</p>
<p>图由节点和边组成。节点表示操作或步骤，边表示依赖关系。pre-g支持复杂应用构建，灵感来源于  和 Apache Beam，接口设计参考了 networkx。</p>
<p>State Graph</p>
<p>Lang-graph最基础的内容是state graph 。每次执行都会创建一个 state，节点执行时会传递和更新该 state。可理解为全局变量，保存整个上下文信息。</p>
<h2 id="多Agent架构的设计与实现"><a href="#多Agent架构的设计与实现" class="headerlink" title="多Agent架构的设计与实现"></a>多Agent架构的设计与实现</h2><p>协作多Agent、主管多Agent及分层多Agent三种架构模式，详细讲解了各自特点、应用场景及代码实现方式。</p>
<p>Ai进程若具有文件系统操作权限，在任何情况下都存在安全隐患，必须在多个容器中运行。</p>
<p>协作多Agent特点</p>
<p>多个Agent共享推理步骤和消息。优点：每个Agent可查看其他Agent的执行步骤。缺点：信息冗长，token消耗大。</p>
<p>协作多Agent架构流程</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803174024894.png" alt="image-20250803174024894"></p>
<p> 任务执行流程用户发起任务，研究员接收并进行任务规划。研究员生成搜索动作，路由器根据动作列表调用工具模块执行搜索。若需绘图，路由器将任务分配给绘图生成器。绘图生成器生成代码并执行，结果返回给图表生成器。信息共享机制所有Agent均可查看执行过程中的所有动作。控制状态转换的模块是基于规则的路由器。</p>
<p>协作多Agent代码实现  </p>
<p> Agent定义</p>
<p>定义创建Agent的方法，包含大语言模型、工具、系统提示词三个参数。提示词模板描述为：AI助手需与其他助手协作，使用工具回答问题。</p>
<p>工具定义</p>
<p>搜索工具：通过注解定义。代码工具：定义Python解释环境，可通过report运行代码。</p>
<p>Agent状态定义</p>
<p>message和thunder两个参数用于创建状态图。</p>
<p>创建两个Agent</p>
<p>researcher：负责研究任务。chart_generator：负责图表绘制。</p>
<p>模型选择</p>
<p>可使用OpenAI或本地部署的Llama等支持工具调用的大模型。注意：base模型不支持工具调用。</p>
<p>协作多Agent图结构实现  </p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803173955811.png" alt="image-20250803173955811"></p>
<p> 节点定义</p>
<p>包括研究员节点、图表节点、工具调用节点。</p>
<p>路由函数</p>
<p>router函数根据消息类型决定是否调用工具或结束任务。</p>
<p>状态图构建</p>
<p>创建状态图并添加节点。router函数判断路由路径。添加条件边，根据编译图结构，运行协作流程。</p>
<p>主管多Agent架构</p>
<p>架构特点</p>
<p>引入专门的Agent负责路由和协调。每个Agent独立运行，拥有自己的任务队列和消息队列。</p>
<p>工作流程</p>
<p>用户请求发送给主管Agent。主管Agent生成规划并路由到相应Agent。Agent完成任务后返回结果给主管，主管继续协调后续任务。</p>
<p>主管多Agent代码实现</p>
<p> 工具定义</p>
<p>使用自定义设计工具，需提供API token。</p>
<p>主管Agent定义</p>
<p>主管Agent具有系统提示词，用于任务规划和路由。</p>
<p>图结构构建</p>
<p>创建react agent，定义研究员、代码生成器等节点。创建添加主管节点并设置条件边，用于路由任务。通过for循环添加成员Agent与主管之间的边。通过编译图结构，执行任务流程。</p>
<p>分层多Agent架构 </p>
<p>架构背景</p>
<p>Agent数量较少时使用协作架构。Agent数量较多时使用主管架构。Agent数量极大时采用分层架构，如总监-主管-小组成员结构。</p>
<p>工作流程</p>
<p>用户请求发送给大主管。大主管将任务路由到各团队。各团队由小主管负责任务分配与协调。</p>
<p>分层多Agent代码实现  </p>
<p>团队定义</p>
<p>网络研究团队：包含搜索、爬虫工具。</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803174724401.png" alt="image-20250803174724401"></p>
<p>文档写作团队：包含大纲编写、文档阅读、文档编辑、代码执行工具。</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803174750931.png" alt="image-20250803174750931"></p>
<p>主管定义</p>
<p><img src="C:\Users\vip\AppData\Roaming\Typora\typora-user-images\image-20250803174852635.png" alt="image-20250803174852635"></p>
<p>创建主管函数，可用于创建子团队主管或大主管。提示词中定义功能描述、名称、参数。</p>
<p>状态图构建</p>
<p>创建子图并添加节点。next添加条件边，根据判断路由路径。编译子图并连接成完整图结构。</p>
<p>多层结构构建</p>
<p>创建研究团队和文档团队的子图。创建超级主管节点，连接两个子团队。设置条件边和普通边，编译超级图结构。</p>
<h2 id="Autogen原理与实战"><a href="#Autogen原理与实战" class="headerlink" title="Autogen原理与实战"></a>Autogen原理与实战</h2><p>论文:<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2308.08155">https://arxiv.org/pdf/2308.08155</a><br>github项目:<a target="_blank" rel="noopener" href="https://github.com/microsoft/autogen">https://github.com/microsoft/autogen</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wutaoblog.github.io">WT</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wutaoblog.github.io/2026/01/11/AI%20agent%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/">https://wutaoblog.github.io/2026/01/11/AI agent 开发知识总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wutaoblog.github.io" target="_blank">WT's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Hexo/">Hexo</a><a class="post-meta__tags" href="/tags/%E5%8D%9A%E5%AE%A2/">博客</a><a class="post-meta__tags" href="/tags/agent/">agent</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/11/hexo%E5%85%A5%E9%97%A8/" title="Typora入门"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Typora入门</div></div><div class="info-2"><div class="info-item-1">Typora入门 文本格式设置： 加粗：在要加粗的文本前后各输入两个星号 “**”，或选中文字后按快捷键 Ctrl+B。 斜体：在要斜体的文本前后各输入一个星号 “*”，快捷键为 Ctrl+I。 粗斜体：在要设置的文本前后各输入三个星号 “***”。 高亮：在要高亮的文本前后各输入两个等号 “&#x3D;&#x3D;”，需在偏好设置的 Markdown 扩展语法内启用。 删除线：在要添加删除线的文本前后各输入两个波浪号 “~~”，快捷键为 Alt+Shift+5。 下划线：选中文字后按快捷键 Ctrl+U，或使用 HTML 标签文本。   标题设置： 输入 “#” 加空格，可创建一级标题，快捷键为 Ctrl+1。 输入 “##” 加空格，可创建二级标题，快捷键为 Ctrl+2，以此类推，最多支持六级标题。   列表创建： 无序列表：使用 “*”“-” 或 “+” 加空格都可以创建，快捷键为 Ctrl+Shift+L。 有序列表：使用 “1.”“2.”“3.” 加空格创建，快捷键为 Ctrl+Shift+O。 任务列表：语法为 “- ()”，减号后、括号内和括号后各有一个空格，括号...</div></div></div></a><a class="pagination-related" href="/2026/01/11/RAG/" title="RAG 入门"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">RAG 入门</div></div><div class="info-2"><div class="info-item-1">RAG什么是RAG? RAG（Retrieval-Augmented Generation，检索增强生成）一种将“信息检索”与“生成式大模型”耦合的架构。系统先通过稠密向量或稀疏检索，从大规模外部知识库中定位与当前查询最相关的文档片段（context），再把这些片段连同原始查询一起送入大语言模型（LLM）作为 prompt 的上下文，让模型在生成回答时既利用内部参数知识，又利用最新的外部知识，从而显著降低幻觉、提升时效性与可溯源性。其典型流程：Indexing → Retrieval → Augmentation → Generation。一句话解释就是：先用“搜索引擎”找到相关文档，再让“作文高手”参考这些资料写答案，既新鲜又靠谱。 实现方式 1.1平台实现 fastgpt、coze、dify等 1.2代码实现 代码有哪些技术栈？  具体技术细节有哪些？  文档提取  1.1txt问本提取 1.2pdf提取工具  1.3表格提前工具 使用Llama Hub中的Database Reader工具连接MySQL数据库，并将数据库表数据加载到Llama Index的Documents...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/11/Agent%20%E5%85%A8%E9%9D%A2%E6%8A%80%E8%83%BD/" title="Agent 全面技能"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">Agent 全面技能</div></div><div class="info-2"><div class="info-item-1">Agent 全面技能（Level-2&#x2F;3）1. 语言与生态 Python 异步&#x2F;协程 FastAPI &#x2F; Flask Node.js + LangChain.js  2. 算法与微调 LoRA &#x2F; PEFT 微调 RLHF（强化学习对齐） 多模态（CLIP、Whisper）  3. 记忆系统 向量数据库（Milvus, Pinecone） 图数据库（Neo4j） 缓存（Redis 语义缓存）  4. Planning 策略 ReAct &#x2F; Reflexion &#x2F; Plan-and-Execute 多 Agent 协作（CrewAI、AutoGen） 状态机与工作流引擎  5. 工具与集成 Function Calling（OpenAI JSON Mode） MCP 协议（Model-Context-Protocol） API Gateway、OAuth、Webhook  6. 安全与合规 Prompt 注入防御 PII 脱敏、审计日志 RBAC 权限模型  7. 运维与评测 LLMOps（CI&#x2F;CD、A&#x2...</div></div></div></a><a class="pagination-related" href="/2026/01/11/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" title="大模型开发学习路线"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">大模型开发学习路线</div></div><div class="info-2"><div class="info-item-1">大模型开发学习路线一、岗位能力地图（你需要会到什么程度）  编程与工程 Python&#x2F;TypeScript，异步与并发，API 设计，单元&#x2F;集成测试，Docker，基础云原生（K8s&#x2F;Helm）。   LLM 基础与调用 token&#x2F;上下文&#x2F;温度&#x2F;采样，系统提示与模式约束（JSON schema）、函数&#x2F;工具调用，多模型路由与回退。   RAG 与检索 数据清洗与切块（chunk）、embedding 选型，混合检索（BM25+向量）、重排（rerank）、重复消解，召回评测。   微调与蒸馏 SFT&#x2F;LoRA&#x2F;QLoRA、指令数据构造、对齐（RLAIF&#x2F;RLHF 基本概念）、量化（INT8&#x2F;4）与部署兼容性。   评测与治理 黄金集构建、离线评测（检索&#x2F;回答&#x2F;安全）、线上反馈闭环、A&#x2F;B、可观测（日志&#x2F;追踪）、版本化与回滚。   推理与部署 vLLM&#x2F;TGI&#x2F;Ollama，连续批处理、KV cache、流式、超...</div></div></div></a><a class="pagination-related" href="/2026/01/11/RAG/" title="RAG 入门"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">RAG 入门</div></div><div class="info-2"><div class="info-item-1">RAG什么是RAG? RAG（Retrieval-Augmented Generation，检索增强生成）一种将“信息检索”与“生成式大模型”耦合的架构。系统先通过稠密向量或稀疏检索，从大规模外部知识库中定位与当前查询最相关的文档片段（context），再把这些片段连同原始查询一起送入大语言模型（LLM）作为 prompt 的上下文，让模型在生成回答时既利用内部参数知识，又利用最新的外部知识，从而显著降低幻觉、提升时效性与可溯源性。其典型流程：Indexing → Retrieval → Augmentation → Generation。一句话解释就是：先用“搜索引擎”找到相关文档，再让“作文高手”参考这些资料写答案，既新鲜又靠谱。 实现方式 1.1平台实现 fastgpt、coze、dify等 1.2代码实现 代码有哪些技术栈？  具体技术细节有哪些？  文档提取  1.1txt问本提取 1.2pdf提取工具  1.3表格提前工具 使用Llama Hub中的Database Reader工具连接MySQL数据库，并将数据库表数据加载到Llama Index的Documents...</div></div></div></a><a class="pagination-related" href="/2026/01/11/%E5%89%8D%E7%AB%AF/" title="前端起步"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">前端起步</div></div><div class="info-2"><div class="info-item-1">前端启动前端项目的步骤： 首先进入前端目录   cd rag-project01-framework&#x2F;frontend  安装依赖（如果还没有安装的话）   npm install  启动开发服务器  npm run dev 一、 项目的逻辑解析1. 项目的“骨架” - 文件结构一个前端项目就像一栋建筑，文件和文件夹就是它的结构。  package.json：项目清单和“身份证”。它记录了项目叫什么名字、版本号多少、依赖了哪些第三方库（如 vue, element-plus, echarts），以及定义了一些快捷命令（如 npm run dev）。  vite.config.ts：项目的“构建配置”。Vite 是我们的构建工具，这个文件告诉 Vite 如何打包我们的代码，比如我们在这里配置了 Element Plus 的自动导入插件。  1src  目录： 项目的“核心代码区” ，我们绝大部分工作都在这里。  main.ts：项目的“入口”。程序从这里开始运行。它的主要工作是创建 Vue 应用实例，并把它“挂载”到 index.html 的一个 DOM 节点上（通常是 ...</div></div></div></a><a class="pagination-related" href="/2026/01/11/typora%E5%85%A5%E9%97%A8/" title="hexo入门"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">hexo入门</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a><a class="pagination-related" href="/2026/01/11/%E8%A7%86%E8%A7%89%E7%AE%97%E6%B3%95/" title="视觉算法"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-11</div><div class="info-item-2">视觉算法</div></div><div class="info-2"><div class="info-item-1">视觉算法1. CV子类CV 包含了图像分类、物体检测、图像分割、人脸识别、OCR（文字识别）、三维重建等众多子方向。 一、图像分类图像分类是 CV 最基础的任务，目标是给图像分配唯一的类别标签（如 “猫”“狗”“汽车”）。    类型 经典算法 &#x2F; 模型 核心特点 &amp; 适用场景    传统算法 1. HOG+SVM2. SIFT+BoW3. KNN &#x2F; 朴素贝叶斯 1. HOG+SVM：早期行人 &#x2F; 车辆分类；2. SIFT+BoW：基于特征词袋的通用分类；3. 简单场景，精度低   深度学习 1. LeNet-5（1998）2. AlexNet（2012）3. VGG-16&#x2F;19（2014）4. GoogLeNet（Inception）5. ResNet（2015）6. MobileNet（2017）7. ViT（2020） 1. LeNet：CNN 开山之作（手写数字识别）；2. AlexNet：ImageNet 夺冠，开启深度学习 CV 时代；3. VGG：规整卷积核设计，易迁移；4. GoogLeNet：多尺度特征融合；5....</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WT</div><div class="author-info-description">记录学习路上的点点滴滴，记得好好生活哦</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/taogehengq"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AI-agent-%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">AI agent 开发知识总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%E8%AF%8D"><span class="toc-number">1.1.</span> <span class="toc-text">提示词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E8%AF%84%E6%B5%8B"><span class="toc-number">1.2.</span> <span class="toc-text">API评测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#agent%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">agent设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">提示工程中的多种设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Agent%E5%BC%80%E5%8F%91"><span class="toc-number">1.5.</span> <span class="toc-text">Agent开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LangChain"><span class="toc-number">1.6.</span> <span class="toc-text">LangChain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LangGraph"><span class="toc-number">1.7.</span> <span class="toc-text">LangGraph</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9AAgent%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.</span> <span class="toc-text">多Agent架构的设计与实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autogen%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="toc-number">1.9.</span> <span class="toc-text">Autogen原理与实战</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/11/Agent%20%E5%85%A8%E9%9D%A2%E6%8A%80%E8%83%BD/" title="Agent 全面技能"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Agent 全面技能"/></a><div class="content"><a class="title" href="/2026/01/11/Agent%20%E5%85%A8%E9%9D%A2%E6%8A%80%E8%83%BD/" title="Agent 全面技能">Agent 全面技能</a><time datetime="2026-01-11T02:00:00.000Z" title="发表于 2026-01-11 10:00:00">2026-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/11/RAG%20%E5%AE%8C%E6%95%B4%E6%8A%80%E6%9C%AF%E6%A0%88/" title="RAG 完整技术栈"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RAG 完整技术栈"/></a><div class="content"><a class="title" href="/2026/01/11/RAG%20%E5%AE%8C%E6%95%B4%E6%8A%80%E6%9C%AF%E6%A0%88/" title="RAG 完整技术栈">RAG 完整技术栈</a><time datetime="2026-01-11T02:00:00.000Z" title="发表于 2026-01-11 10:00:00">2026-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/11/RAG/" title="RAG 入门"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RAG 入门"/></a><div class="content"><a class="title" href="/2026/01/11/RAG/" title="RAG 入门">RAG 入门</a><time datetime="2026-01-11T02:00:00.000Z" title="发表于 2026-01-11 10:00:00">2026-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/11/AI%20agent%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="AI agent 开发知识总结"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI agent 开发知识总结"/></a><div class="content"><a class="title" href="/2026/01/11/AI%20agent%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="AI agent 开发知识总结">AI agent 开发知识总结</a><time datetime="2026-01-11T02:00:00.000Z" title="发表于 2026-01-11 10:00:00">2026-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/11/hexo%E5%85%A5%E9%97%A8/" title="Typora入门"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Typora入门"/></a><div class="content"><a class="title" href="/2026/01/11/hexo%E5%85%A5%E9%97%A8/" title="Typora入门">Typora入门</a><time datetime="2026-01-11T02:00:00.000Z" title="发表于 2026-01-11 10:00:00">2026-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By WT</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>